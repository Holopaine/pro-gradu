\documentclass[utf8]{gradu3}
% \usepackage{graphicx} % kuvien mukaan ottamista varten \usepackage{amsmath} %
% hyödyllinen jos tekstisi sisältää matikkaa,
                     % ei pakollinen
% \usepackage{booktabs} % hyvä kauniiden taulukoiden tekemiseen

% HUOM! Tämän tulee olla viimeinen \usepackage koko dokumentissa!
\usepackage[bookmarksopen,bookmarksnumbered,linktocpage]{hyperref}

\addbibresource{pro-gradu.bib} % Lähdetietokannan tiedostonimi

\begin{document}

\title{Avoimen lähdekoodin projektien ohjelmistovirheiden korjausajan arviointi tiedonlouhimismenetelmin}
\translatedtitle{Pro Gradu (to be\dots)}
\studyline{Ohjelmistotekniikka} \avainsanat{} \keywords{}
\tiivistelma{Tiivistelmä}
\abstract{}

\author{Lauri Holopainenn}
\contactinformation{\texttt{lauri.m.s.holopainen@jyu.fi}}
% jos useita tekijöitä, anna useampi \author-komento 
\supervisor{Ville Isomöttönen}
% jos useita ohjaajia, anna useampi \supervisor-komento

\maketitle

\mainmatter

\chapter{Johdanto}
% - Bugit
%   * Käytännön tärkeys.
%   * Tieteellinen merkitys.
Ohjelmistokehityksen ja  ja ohjelmistojen ylläpidon keskeisiä ongelmia ovat
ohjelmointivirheet eli bugit. Mitä myöhemmässä vaiheessa bugit huomataan, sitä
enemmän resursseja, siis työaikaa, voi olettaa kuluvan niiden korjaamiseen. Olen
kiinnostunut siitä, kuinka bugikorjauksiin kuluvaa aikaa voisi arvioida
matemaattisten mallien avulla. Tutkielmassani aion selvittää, voisiko nyt jo
kehitettyjä malleja muuttaa tarkemmiksi tuomalla samaan malliin parhaita
piirteitä useista tutkimuksista.

Modernissa ketterässä ohjelmistokehitystyössä hyödynnetään usein erilaisia
tikettijärjestelmiä bugien ja kehitysideoiden raportointiin. Tiketit voivat
saada alkunsa niin loppukäyttäjien, kuin kehittäjäorganisaation huomioista. Kun
tiketin vastaanottaja kuittaa tehtävän työn alle, hän arvioi tarvittavan
ohjelmistomuutoksen kriittisyyden, nimittää sen jollekin kehittäjälle, ja arvioi
siihen kuluvan ajan. Kuluvan ajan sijaan voidaan myös arvioida tehtävän
haasteellisuutta (\textit{story points}). Onnistunut tehtävän vaatiman ajan
arviointi voi auttaa kehitysprojektin vetäjiä suunnittelemaan aikataulun
suunnittelussa ja resurssien suuntaamisessa. Loppukäyttäjiä hyvät
korjausaika-arviot voivat myös hyödyttää esimerkiksi oman työnsä suunnittelussa
tai sen arvioinnissa, että onko järkevää jäädä odottamaan korjauksen
valmistumista.

Bugikorjausten valmistumisaikaa on yritetty arvioida louhimalla tietoa
tikettijärjestelmiä, ja luomalla tilastollisia malleja muun muassa koneoppimisen
avulla. Yksi käytetyimpiä mittareita on aika tiketin avaamisesta sen
sulkeutumiseen. Tutkimuksissa saadut tulokset ovat kuitenkin olleet välillä
ristiriitaisia, eivätkä aina kovinkaan tarkkoja. Vaikuttaisi siis siltä, että
lisätutkimuselle on tarvetta mikäli näitä malleja halutaan soveltaa käytännössä
osana.

% Shaikh-2017 -> alkulähteet: Kehittäjät eivät ole sopimuksin sitoutineita
% organisaatioon, vaan motivaatio ohjelmointiin löytyy muista tekijöistä
% (ulkoinen ja sisäinen). Myös tehtävät ovat kehittäjien itsensä valitsemia. 

\chapter{Ohjelmistokehitys avoimen lähdekoodin projekteissa}
Avoimen lähdekoodin ohjelmia hyödynnetään paljon osana tietojärjestelmiä.
Esimerkiksi LAMP-kokoonpano on suosittu web-ohjelmien kehityksessä. Osa avoimen
lähdekoodin ohjelmistoista, kuten Gimp \footnote{https://www.gimp.org/}, on
tarkoitettu suoraan loppukäyttäjälle. Avoimen lähdekoodin ohjelmistot ovat
yhdistetty johonkin lisenssiin, joka määrittää niiden käyttö- ja jakeluehdot.

Avoimen lähdekoodin ohjelmistojen käyttöä edistävä Open Source Initiative (OSI)
-järjestö on määritellyt kriteerit avoimen lähdekoodin ohjelmille ja
lisensseille \parencite{Osd}. Kriteerien täyttävää ohjelmaa ja sen lähdekoodia
saa vapaasti jakaa, muokata ja käyttää sellaisenaan tai osana muita
ohjelmistoja. Vapaan lähdekoodin ohjelmiston lisenssi ei voi kriteerien mukaan
rajoittaa ohjelman käyttöä tarkoituksen tai käyttäjän perusteella. Kriteerit
sallivat ohjelmiston kopioiden myymisen. WhiteSourcen tekmemän tutkimuksen
mukaan suosituimpia avoimen lähdekoodin lisenssiä olivat Apache 2.0, MIT, ja GPL
v3 \parencite{Whitesource-2021}.

Ilmaisohjelmat, eli freeware-ohjelmat, eivät usein täytä avoimen lähdekoodin
ohjelmiston kriteereitä, sillä vaikka niitä saa jakaa maksutta, usein niiden
lähdekoodia ei ole julkistettu. Myöskin ilmaisohjelmien tekijä tai
tekijänoikeuksien haltija on rajoittanut ohjelman käyttöä kaupallisissa
tarkoituksissa.
\parencite{Corbly-2014}

Avoimen lähdekoodin ohjelmistoja kehitetään usein yhteisöllisesti
vapaaehtoisvoimin. Kehitykseen osallisuu ydinhenkilöiden lisäksi loppukäyttäjät
vaihtelevin panoksin. Motivaation lähteinä projekteihin osallistujilla voi olla
esimerkiksi työstä itsestään saatu sisäisesti motivoitunut tyydytys,
velvollisuudentunto yhteisöä kohtaan, tai siitä saatu rahallinen korvaus
\parencite{Lakhani-2005}. Myös ohjelmistoyritykset voivat osallistua avoimen
lähdekoodin ohjelmistojen kehitykseen. Viime aikoina perinteiset ohjelmistoalan
yritykset ovat alkaneet julkaista ohjelmiaan avoimen lähdekoodin lisenssien
alla. (Lähde?)

\section{Projektin kehityskaari}
Avoimen lähdekoodin ohjelmistoprojektien alullepano voi tapahtua monin eri
tavoin. \textcite{Conlon-2007} perehtyi nimekkäiden avoimen lähdekoodin
projektien alkuun, kehittäjäyhteisöön ja johtamiseen. Osa projekteista oli
aloitettu rakentamalla uutta ohjelmistoa vanhan hylätyn ohjelmiston päälle.
Muutaman ohjelmiston juuret olivat yliopistoprojekteissa.
\textit{OpenOffice.org} julkaistiin avoimena lähdekoodina yrityskauppojen
seurauksena. \textit{MySQL} oli yhtäaikaa sekä avoimen lähdekoodin projekti,
että kaupallisen yrityksen omistuksessa. \textit{Linux} muuttui yhden henkilön
projektista avoimen lähdekoodin ohjelmistoksi Usenet-ryhmässä julkaistun
ilmoituksen myötä. \parencite{Conlon-2007}

Forkkaus, eli projektin haarautuminen useaksi itsenäiseksi projektiksi on myös
mahdollinen alku uudelle avoimen lähdekoodin projektille. \textcite{Nyman-2013}
mukaan forkkaus tuo kestävyyttä ja turvaa ohjelmiston jatkuvuudelle ohjelmiston,
yhteisön ja ekosysteemin tasoilla. Heidän mukaan ohjelmistotasolla forkkaus tuo
turvaa koodin mätänemistä ja vanhenemista vastaan. Yhteisötasolla projektin
haarautuminen mahdollistaa itsenäisen projektin luomisen siinä tapauksessa, jos
alkuperäisen projektin suunta tai vetäjien päätökset eivät miellytä yhteisöä.
Ekosysteemitasolla forkkaus mahdollistaa \textcite{Nyman-2013} mukaan hylättyjen
projektien henkiinherättämisen ja parantaa innovaatioiden mahdollisuutta
projektien ydistämisen ja muokkaamisen kautta. Esimerkiksi Linux jakeluista on
forkattu lukuisia haaroja, jotka vastaavat erilaisiin tarpeisiin ja
mieltymyksiin.

\textcite{Laurent-2004} mukaan forkkausta myös pelätään, koska voi hajoittaa
kehittäjäyhteisön kahtia, kuten kävi Emacs projektille 1993. Vakavimmillaan
alkuperäinen projekti voidaan hylätä. Näin kävi \textcite{Viseur-2012}
tutkimuksessa 19\% tapauksista. Laurentin mukaan avoimen lähdekoodin "copyleft"
lisensseillä pyritään joskus rajoittamaan forkkausta muun muassa vaatimalla
yhteensopivaa lisenssiä myös haarautuville projekteille. \textcite{Viseur-2012}
havaintojen mukaan tämä ei kuitenkaan ole erityisen varma tapa, sillä yli puolet
tutkimuksessa mukana olleista haaroista oli suojattu "copyleft"-lisenssillä.
Toinen tapa rajoittaa forkkausta on alkuperäisen projektin nimen suojaaminen.
Tällä tavalla on Apache -projekti säilyttänyt selkeän kehityslinjan. Suljetun
lähdekoodin projeteissa forkkausta ei juuri tapahdu, sillä ne eivät salli
lähdekoodin uudelleenkäyttöä toisissa projekteissa \parencite{Conlon-2007}.

Projektin alullepanon jälkeisiä vaiheita ovat vapaaehtoisten haalinta,
ratkaisujen identifioiminen, kehitys ja testaaminen, vertaisarviointi,
dokumentointi ja julkaisun hallinta \parencite{Sharma-2002}. Koska modernit
ohelmistoprojektit ovat luonteeltaan iteratiivisia ja koska uusia vapaaehtoisia
voi liittyä avoimen lähdekoodin projektin kehitysyhteisöön koska vain, voisi
näiden vaiheiden nähdä toistuvan ja tapahtuvan ainakin osin yhtäaikaa.

Uusien kehittäjien haalimiseksi \textcite{Riehle-2015} esittää projektin
näkökulmasta kaski väylää aktiivisen etsimisen ja passivisen sisäänvirtauman.
Aktiivista etsimistä suoritetaan Riehlen mukaan aktiivisella näkyvällä
viestinnällä asiaankuuluvissa mediakanavissa. Nykyään ohjelmistoalalla toimivien
suosimat some-väylät voisi nähdä hyvänä väylänä tähän. Passiivista
vapaaehtoisten haalintaa on Riehlen mukaan esimerkiksi hakukoneiden tukeminen ja
avoimen lähdekoodin projekteja listaaviin portaaleihin kirjautuminen. Riehle
nostaa esille myös projektin esittelyn ja dokumentoinnin merkityksen, kun uusi
käyttäjä tai mahdollinen kehittäjä tutustuu projektiin. Dokumentaation,
tutoriaalien kirjoittaminen ja käytäntöjen selkeyttäminen auttoi myös
Mozilla-projektia keräämään osallistujia alun vaikeuksien jälkeen
\parencite{Mockus-2002}.

Avoimen lähdekoodin projektien suosimat alustat versiohallintajärjestelmille,
kuten GitHub, mahdollistavat ohjelmiston kehittämisen hajautetusti. Lähdekoodin
kirjoittamisen ja testaamisen onnistuu lokaalissa ympäristössä, ja
muutostiedostoja voidaan antaa yhteisön tarkasteltavaksi pilvipalvelun kautta.
(Tarviiko lähdettä?) \textcite{Sharma-2002} mukaan kehitystyötä voidaan tehdä
joko yksin, tai osana väliaikaista tiimiä. Ennen muutostiedoston hyväksymistä,
sen tulee käydä läpi vertaisarviointi, jossa muut projektiin osallistuvat
katselmoivat lisättävän koodin sen laadun varmistamiseksi, sekä antavat siitä
palautetta. Vertaisarviointikäytänteet vaihtelevat projekteittain, joskus koodi
luotetun kehittäjän kirjoittama koodi voidaan lisätä projektiin jo ennen
katselmointia \parencite{Wang-2015,Rigby-2008}.

% (Perusteet sille miksi kehityksen ohjaus on tärkeää laadun ja virheiden
% kannalta. Tarvitaanko vertailua teollisuusprojektien vastaaviin käytäntöihin?)

\section{Projektin hallinta}
%Erilaiset organisatiot: Hierarkinen ja keskitetty (Linux), modulaarinen jne...
Hyvin menestyneet avoimen lähdekoodin ohjelmistoprojektit houkuttelevat paljon
osallistujia. Jossain vaiheessa kasvaneen projektin ohjaamisen, päätöstenteon ja
vastuiden jakamisen tueksi syntyy hallinnan järjestelmä. \textcite{Muller-2009}
määrittelee hallinnan läpinäkyvyyteen, vastuullisuuteen ja määriteltyihin
rooleihin pohjaavaksi viitekehykseksi päätösten ja toimenpiteiden tekemiselle.
Müllerin mukaan se muodostuu arvojärjestelmistä, vastuista, prosesseista ja
käytännöistä, jotka auttavat projektia kohti sen tavoitetta. Se myös asettaa
rajat mahdollisille johtamistoimille ja selkeyttää eroa omistajuuden ja
työtehtävien kontrollin välillä\textsuperscript{tarkenna?}
\parencite{Muller-2009}. \textcite{Markus-2007} määrittelee avoimen lähdekoodin
projektinhallinnan keinoiksi suunnata ja koordinoida kehitysprojektiin
osallistuvia itsenäisiä yksilöitä ja organisaatioita. Erityisenä huomioina voi
todeta, että näitä keinoja ei välttämättä ole formaalisti dokumentoitu, vaan ne
voi toteutua myös informaalisti jaettujen normien ja sosiaalisen kontrollin
kautta, tai toteutua käytetyn teknologian, kuten versiohallintajärjestelmän,
kautta \parencite{Markus-2007}. Projektinhallinta siis vaikuttaa sekä korkean
tason päätöksentekoon, että kehitystyötä ja -tehtäviä ja osallistujien välistä
komminikaatiota yksittäisten ohjelmistoa koskevien ongelmien ratkaisuun.

Onnistunut projektinhallinta edesauttaa projektia saavuttamaan päämääränsä
menestyksekkäästi. \textcite{Samset-2016} esittää, että projektin menestystä
strategisella tasolla voidaan mitata tarkastelemalla projektin relevanttiutta,
efektiivisyyttä ja kestävyyttä, jolloin projekti vastaa yhteisön tarpeisiin.
Taktisen tason menestyksen mittareita ovat projektin tulosten hinta, laatu, ja
käytetty aika, joita voidaan verrata projektin sisäisiin tavoitteisiin.
\parencite{Samset-2016}. \textcite{OMahony-2007} nostaa kirjallisuudesta kolme
avoimen lähdekoodin projektien ongelma-aluetta, joihin projektinhallinnan
keinoin voidaan vastata. Hänen mukaan se voi olla osana ratkaisua kollektiivisen
toiminnan ongelmiin, kuten vapaaehtoistyöhön motivoimisesen ja osallistumiseen
kannustavien mekanismien luomiseen. Projektinhallinnan keinoin ratkaistaan myös
yleisiä kehitystyön aikaisia ongelmia, kuten keskinäisten riippuvuuksien ja
laadun hallintaan tai vapaaehtoisten rekrytointiin. Kolmantena ongelma-alueena
O’Mahony tuo esille projektiyhteisön ilmapiirin luomisen. Yhteisön jäseniä
miellyttävät hallintakeinot voivat nousta työskentelyn motivaation lähteeksi
muiden työn tuloksena ilmenevien itseis- ja välinearvojen joukkoon
\parencite{OMahony-2007}.

% Tarvitaanko esimerkkejä päätöksistä tai jotain muuta. DE LAAT!!
\textcite{Laat-2007} erittelee kuusi kategoriaa, joihin avoimen lähdekoodin
ohjelmistoprojektien sisäisen hallinnan työkalut voidaan jakaa: modularisointi,
roolien jakaminen, päätöksenteon delegointi, koulutus ja idoktrinaatio,
formalisointi ja demokraattisen tai autokraattisen hallintomuodon painotus.
% Millasta governanssia pienessä rojektissa?

Modularisoinnilla tarkoitetaan ohjelmiston jakamista pienempiin itsenäisiin
osiin. Samaan aikaan voidaan kehittää myös saman ohjelmiston eri versioita.
Modularisoinnin avulla ohjelmiston osien, ja samalla myös kehittäjien,
keskinäinen riippuvuus vähenee, eikä kehittäjän tarvitse tuntea koko
järjestelmää osallisuakseen moduulin kehitykseen \parencite{Lee-2001}. Myös
projektin jatkuvuus paranee, koska uusien kehittäjien on helpompaa liittyä
yhteisöön, kun osallistumisen voi aloittaa helpommin ymmärrettävistä moduuleista
\parencite{Aberdour-2007,Lee-2001}.

Roolien jakamisella \textcite{Laat-2007} tarkoittaa eri tasoisten
osallistumisoikeuksien jakamista osallistujille pelkästä tarkkailuoikeudesta
lähdekoodin vapaaseen muokkausoikeuteen. Oikeuksien lisäksi roolien perusteella
jaetaan myös vastuualueita, joita voivat olla voi olla esimerkiksi kääntäjä ja
ylläpitäjä \parencite{Laat-2007}. Rooleja ei ole aina formaalisti määritelty,
vaan usein esimerkiksi bugiraportteja tai -korjauksia voi luoda kuka tahansa
asiasta kiinostunut. \textcite{Yuan-2010} havaitsivat, että suosituissa avoimen
lähdekoodin projekteissa osallistujat käyttivät ainakin kolmea eri roolia. He
arvelivat, että menestyksekkäissä projekteissa työnjako on onnistunut, mihin on
osaltaan vaikuttanut vapaaehtoisten roolittaminen. Projektiin osallistuja voi
olla yhtä aikaa monessa roolissa, ja osallistujan rooli voi myös muuttua
yhteisössä ja yhteisön ulkopuolella tapahtuvan kehityksen myötä
\parencite{Trinkenreich-2020}. Tutkimuksessa usein käytetty malli avoimen
lähdekoodin projektien roolien jakautumiselle on sipulimalli, missä projetkiin
osallistuvat jaetaan  suurimman osan ohejelmoinnista tekeviin ydinkehittäjiin,
satunnaisia palasia kirjoittaviin oheiskehittäjiin, ja projektin vetäjiin
\parencite{Crowston-2005, Mockus-2002}. Sipulimallia on käytetty paljon avoimen
lähdekoodin projektien tutkimuksessa, sillä se jakaa projektin kehittäjät
mitattavalla tavalla kahtia \parencite[esim.][]{Setia-2012,Alfayez-2017}.

Roolit jakautuvat myös päätöksenteko-oikeuden mukaan, jolloin
\textcite{Laat-2007} mukaan hallinnan työkaluna on päätöksenteon delegointi
Esimerkiksi projektilla voi olla yksi päävetäjä, joka tekee koko ohjelmistoa
koskevia päätöksia, sekä useita ylläpitäjiä, jotka vastaavat itsenäisten
moduulien vetämisestä. Koko projektia ja yhteisöä koskevien päätösten lisäksi de
Laat näkee keskeiseksi päätöskohteeksi uuden lähdekoodin hyväskynnän.
Päätöksentekoa voidaan keskittää tai hajauttaa. Keskitetyssä mallissa
yksittäiset vetäjät tekevät päätökset lähdekoodin hyväskynnästä, kun taas
hajautetussa mallissa kehittäjät päättävät yhdessä mukaan otettavasta
lähdekoodista. Päätöksenteon tukena voidaan käyttää esimerkiksi
vertaisarviointia ja äänestystä. \textcite{Heckman-2007} havaitsivat, että
onnistuneissa avoimen lähdekoodin projekteissa päätköksenteko ja siihen liittyvä
keskustelu siirtyi projektin ylläpitäjältä enemmän yhteisön vastuulle, kun
projekti siirtyi alkuvaiheesta eteenpäin. Päätöksentekijöitä siis ei ole aina
määritelty, vaan päätöksenteko sallitaan yhteisöstä riippuen eri tavalla
mukana olleille. Myöskään päätöksen tekeminen ryhmässä ei aina ole suoraviivainen
prosessi, vaan siinä voi olla useita arviointi, ja kehittelyvaiheita
\parencite{Eseryel-2020}.\marginpar{Yhteenvetoa?}

Luomalla yhteisöön kriteerit sille kuka voi osallistua ja ehdottaa muutoksia
lähdekoodiin, voidaan de Laatin mukaan pyrkiä parantamaan
ohjelmiston laatua ja luotettavutta. Koulutuksella ja indoktrinaatiolla pyritään
tarjoamaan halukkaille osallistujille mahdollisuus kehittää omaa osaamistaan
sille tasolle, että seylittää projektin asettamat osallistumiskriteerit
\parencite{Laat-2007}.

Ohjelmiston ja projektin kehitystehtävien ja raportoinnin formalisointiin
on kehitetty työkaluja, joita avoimen lähdekoodin projekteissa on otettu
laajasti käyttöön. \cite{Laat-2007} mukaan vakiinnutetut tavat ja työkalut
helpottavat suurten kokonaisuuksien hallintaa, sekä osallistujien siirtymistä
projektien välillä. Avoimen lähdekoodin projekteissa tärkeimpiä työkaluja ovat
Git ja GitHub. Git on hajautettu versiohallintajärjestelmä, joka tarjoaa
työkaluja kehittäjille kuin ylläpitäjille. GitHub on alusta Gitiä käyttäville
projekteille, joka koodin säilyttämisen lisäksi tarjoaa paljon työkaluja
yhteisölliseen kehittämiseen ja raportointiin. Tällaiset teknologisten
välineiden myötä projekteihin kantautuvat formaalit prosessit kenties
toimivatkin paremmin, kuin tarkkaan dokumentoidut säännöt ja ohjeet
osallistumiselle, sillä ne skaalautuvat automaattisesti projekitin kasvun
mukana. \textcite{Schweik-2007} huomasivatkin avoimen lähdekoodin projektien
vetäjiä haastatellessaan, että osallistujat välttivät formaalien protokollien
kirjoittamista, ja luottivat sosiaalisen kanssakäynnin mukana muodostuviin
informaaleihin konventioihin.

Viimeisenä projektinhallinnan keinona De Laat huomioi projektiyhteisön
rakenteen ja päätökenteon painottumisen autokraattiseen tai demokrattiseen
suuntaan. Hän kertoo, että pienemmissä projekteissa projektin aloittaja usein
pitää itsellään päätäntävallan ja johtoaseman projektin suunnasta, mutta
suureksi kasvaneissa projekteissa vetäjien valinta voidaan hoitaa
demokraattisemmin, jolloin yhteisön jäsenet voivat vaikuttaa projektin
johtohahmoihin. Projektin vetäjäksi voidaan valita yksi henkilö tai useasta
jäsenestä koostuva ryhmä. Toisaalta esimerkiksi Apache-projektia johtaa
vaaleilla valittu lautakunta, ja projekti kertookin vastuun antamisen
perustuvan meritokraattiseen, näyttöihin perustuvaan, luottamukseen \parencite{Apache-2021}.
Demokraattisen tai autokraattisen hallintotavan valinnalla voisi ajatella
olevan vaikutusta päätkösenteon nopeuteen ja osaamiseen, ulkopuolisiin
suhteisiin, roolien jakamisen tärkeyteen sekä ohjelmiston hyväskyntään muissa
yhteisöissä. Avoimen lähdekoodin projektin kehitystä autokratiasta kohti
demokratiaa ja meritokratiaa projektin kasvun myötä tukee myös
\textcite{OMahony-2007b} havainnot, jotka tutkivat Debian-projektin alullepanijan
lähdön myötä syntynyttä prosessia, jonka päätteeksi projektiin syntyi henkilöstä
riippumattomia hallintotason instituutioita. Heidän havaintojen mukaan
demokraattisestikaan valittujen projektin vetäjien ei odoteta tekevän
päätöksiä omin päin, vaan toimivan konseksuksen rakentajina ohjelmiston
kehitystä koskevissa keskusteluissa.

Mainituista kategorioista kaikkia voi hyödyntää samassa projektissa, ja jotkin
työkalut voikin nähdä vaikuttavan projektin hallintaan useamman kategorian
näkökulmasta.


% Ohjelmistokehitystyössä ketterillä menetelmillä pyritään iteratiivisin ja
% joustavin prosessein nopeaan julkaisutahtiin, jatkuvaan kehitykseen ja kykyyn
% vastata muutostarpeisiin. Suosituimmat ketterän kehityksen prosessimallit,
% kuten Scrum ja Lean, sopivat hyvin kaupallisiin ohjelmistoprojekteihin, joissa
% on vakaa, palkatuista jäsenistä koostuva, kehitysorganisaatio.

(Laadun hallinta)

\section{Vertaisarviointi ja bugien raportointi}
 (Ehkä oma kappale siitä mitä tapahtuu ennen vertaisarviointia?)

Kun ohjelmiston lähdekoodia muokataan, on usein kyse joko siitä, että ohjelmaan
tuodaan uusia ominaisuuksia lisäämällä uutta koodia, tai korjataan
ohjelmointivirheitä muokkaamalla olemassa olevaa ohjelmakoodia (\textit{patch}).
Ennen ohjelmointia kehitysalustalle luodaan usein tiketti, jossa kuvataan
kehitettävä ominaisuus tai ohjelmistossa havaittu virhe. Tiketin yhteyteen voi
myös liittyä keskustelua kyseisestä tehtävästä.%
Tehtävätiketin verifiointi, luokittelu, priorisointi ja delegointi tapahtuu
triage-vaiheessa.%
Verifioinnin tarkoituksena on selvittää, onko raportoitu bugi toistettavissa tai
onko virhe kyseisen ohjelman sijaan jossain muualla, esimerkiksi käyttäjän
virhe.%
Luokittelemalla voidaan tehtävien osoittaa liittyvän tiettyyn ohjelmiston osaan,
jolloin vastuu tehtävän hoitamisesta voidaan siirtää kyseistä osaa kehittäville
henkilöille.%
Priorisoinnilla pyritään järjestämään tehtävät niiden tärkeyden ja kriittisyyden
perusteella. Korkeamman prioriteetin tehtävät halutaan hoitaa ennen pienemmän
prioriteetin tehtäviä.%
Koska avoimen lähdekoodin projekteihin osallistutaan usein vapaa-ajalla,
tehävien delegointi tapahtuu usein kehittäjien omien mielenkiinnon- ja
osaamiskohteiden sekä käytettävissä olevien resurssien perusteella.%
Triagen voi hoitaa joko yksi projektiin perehtynyt kehittäjä, tai ryhmä
kehittäjiä.

Keskeisimpiä menetelmiä ohjelmiston laadun parantamiseksi ja virheiden
korjaamiseksi avoimen lähdekoodin projekteissa on vertaisarviointi ja
koodin katselmointi. \parencite{Rigby-2014} Katselmoinnissa ohjelmiston
kehittäjät katselmoivat ja testaavat toisten kehittäjien lisättäväksi
ehdottamaa koodia. Vertaisarvioinnin tavoitteena on löytää bugeja ja
muita virheitä mahdollisimman aikaisin. \textcite{Rigby-2014} kuvaavat avoimen
lähdekoodin projekteissa yleistä broadcast -tyylisen vertaisarviointikäytännön
vaiheita seuraavasti:
\begin{enumerate}
  \item Projektin osallistuja toteuttaa muutoksen koodiin (\textit{patch}).
  \item Osallistuja julkaisee muutostiedoston projektin käyttämää väylää pitkin,
        jolloin sen näkee suuri joukko siitä mahdollisesti kiinnostuneita
        kehittäjiä.
  \item Julkaistu muutosehdotus joko jää huomiotta, tai se katselmoidaan ja siitä
        annetaan palautetta julkaisijalle samaa julkista väylää pitkin.
  \item Muutoksesta käydään keskustelua ja sitä parannellaan, kunnes se lopulta
        hylätään tai hyväksytään osaksi ohjelmiston lähdekoodia.
\end{enumerate}

\textcite{Rigby-2012} esittävät, että avoimen lähdoodin projekteissa
tapahtuvalle hajautetulle vertaisarvioinnille yleisiä piirteitä on mm.
asynkronisuus, katselmointien tiheys, katselmoitavien muutosten pieni koko ja
katselmoijien erityisosaaminen tarkasteltavaan koodiin liittyen. Heidän
mukaan aikatauluista riippumattoman asynkronisen arviointimallin johdosta
koodikatselmointia varten ei tarvitse löytää kaikille osallistujille sopivia
aikoja, vaan sen voi suorittaa arvioijalle itselleen sopivivimmalla hetkellä.
Usein ja pienissä paloissa tehtynä katselmointi ei ole työlästä vapaaehtoisena
toimiville osallistujille, ja lisättävä koodi on mahdollista tarkastaa
huolellisesti. Katselmoinnin laatu paranee, kun siihen osallistuu muutettavan
ohjelmiston osan hyvin tuntevia tekijöitä, jotka saavat itse valita arvioitavat
muutokset \parencite{Rigby-2012, Rigby-2014}.

Koska virheiden etsiminen ja niiden
raportointi on osa vertaisarviointia, myös ohjelmien loppukäyttäjät
osallistuvat usein vertaisarviointiin raportoimalla löytämiään bugeja, vaikka
eivät itse muuten osallistuisi niiden korjaamiseen tai ohjelmiston kehttämiseen.
Bugien raporointi- ja raporttien käsittelykäytänteetvaihtelevat projektien välillä.
\textcite{Wang-2015} havaitsivat Mozilla- ja
Python -projekteja vertaillessaan, että Mozilla-projektiin raportoidut bugit
kuvattiin usein käyttökokemuksen avulla, kun taas Pythonin bugiraportit
sisältivät monesti raportoijan kirjoittaman korjauspaketin lähdekoodiin.
Raporttien verifioinnissa ja kommentoinnissa nousi Mozilla-projektissa esille
riittävän tarkan informaation kerääminen, ja Python-projektissa keskityttiin
enemmän korjauspaketin katselmointiin ja testaukseen. Mozilla-projektissa
bugiraportit kirjattiin Bugzilla-bugiseurantaohjelmaan ja Python projektissa
Roundup-ohjelmaan. Mozilla-projektissa raporttien luokittelu oli tarkempaa ja
käytettäviä nimikkeitä (\textit{label}) oli huomattavasti enemmän.
\parencite{Wang-2015}

GitHubin tarjoama työkalu bugiraporttien kirjaamiselle (\textit{issues}) on
melko joustava, ja nimikkeet ovat sen ainoa keino luokitteluun ylläpitäjien
määräämien kenttien perusteella. Sen lisäksi issues-työkalua käytetään muidenkin
kehitystehtävien kirjaamiseen.  Onkin siis syytä olettaa, että tässä
tutkimuksessa käytettävien avoimen lähdekoodin ohjelmistoprojektien välillä on
eroja bugien raportoinnissa ja vertaisarvioinnin käytännöissä.

\chapter{Tiedonlouhinta ja koneoppiminen}
% - Tiedonlouhinta
%   * Menetelmät, arviointi.
% - Tekstin prosessointi tiedonlouhinnassa.
% - Mining software repositories Issue resolution time/bug fixing time
%   estimation.

% Projektikohtiaset vs. yleistettävät featuret?
Moderni yhteiskunta tuottaa ja tallentaa dataa jatkuvalla virralla. Pelkkä data
itsessään ei vielä ole tietoa tai tietämystä. Jotta siitä saataisiin
ymmärretäävää ja kiteytynyttä tietoa, se vaatii tulkintaa ja yhdistämistä muuhun
ympäristössä olevaan tietoon. % Pitäiskö keksiä jotain omaperäisempää :D
Informaatiojärjestelmiin kerättyä, ja niiden itse keräämää, dataa on usein niin
paljon, ettei sitä ole mahdollista käsitellä manuaalisin menetelmin
(ääriesimerkkinä Big data). Tiedonlouhinnan voi määritellä oleellisen tiedon ja
kiinnostavien kaavojen löytämiseksi suuresta datamassasta
\parencite[][8]{han-data_mining}. Alalla käytetään monenlaisia tilastotieteen,
matematiikan ja tietojenkäsittelyn tekniikoita \parencite{clifton-2019}.

Ohjelmistokehityksessä hyödynnetään usein hajautettuja
versiohallintajärjestelmiä kuten Git, sekä internet-palveluja kuten Github ja
Bitbucket tietovarastojen (\textit{repository}) hallintaan. Nämä palvelut
tarjoavat usein lähdekoodin jakamisen lisäksi myös muita ominaisuuksia, kuten
jatkuvan integraation kanavan, pull requestit, ja bugiraportit. Mining software
repositories (MSR) on tiedonlouhinnan osa-alue, joka on erikoistunut
ohjelmistokehityksessä syntyvän strukturoidun ja tekstimuotoisen datan
käsittelyyn. Tutkimuksen kohteita ovat esimerkiksi koodin mätäneminen, muutosten
riippuvuus, bugien ennakointi ja syyt, sekä kehittäjien yhteistyö.
\parencite{guemes-pena-emerging_topics}

\section{Tekstin prosessointi tiedonlouhinnassa}
\begin{itemize}
  \item Stemmaus
  \item TF-IDF
  \item Haasteet
\end{itemize}
\section{Random tree ja Random Forest}
\begin{itemize}
  \item Algoritmien kuvaus
  \item Arviointi
  \item Toimivuus aiemmissa sovelluksissa
\end{itemize}

\section{Bugien korjausajan arviointi}

% Motivaatio koneavusteisen korjausajan arvioinnin olemassaololle. Käytännön
% syyt.
% * kustannusten arvionti
% * delegointi
% * loppukäyttäjien tarpeet
% * muiden ohjelmistojen riippuvuudet
% * sisäisten ja ulkoisten tarpeiden tyydyttäminen hyvissä ajoin? Tieteelliset
%   syyt.

\subsection{Aiemmat koneoppimiseen perustuvat mallit}
Malleja ohjelmistobugien korjausajan arviointiin on kehitetty useissa
tutkimuksissa 2010-luvulla. Dataa on kerätty niin avoimen kuin suljetun
lähdekoodin projekteista. Näistä valtaosa on julkaistu konfferenssipapereina.
Joistakin löytyy myös pidempi artikkelimuotoinen teksti. Kirjallisuutta on
löytynyt eniten ACM DL ja IEEE -tietokannoista, sekä seuraamalla viitteitä
snowballing-tekniikalla. Tutkimukset eroavat muun muassa mallin kehityksessä
käytettyjen projektien määrässä, hyödynnetyissä attribuuteissa ja
koneoppimisalgoritmeissa.

\textcite{Anh-2011} tutkivat kehittäjäkohtaisten attribuuttien merkitystä bugien
korjausaikojen suhteen. Vahvimpana havaintona he huomasivat kehittäjän aiemmin
korjaamien bugien korjausaikojen keskiarvon olevan potentiaalinen muuttuja,
jonka mukaan ottaminen paransi koneoppimisalgoritmin tuottaman mallin tarkkutta
2.87-12.07\%.

\textcite{Giger-2010} tutkivat bugien luokittelua hitaasti ja nopeasti
ratkaistaviin. Aineistona he käyttivät kuutta Eclipse-, Mozilla- ja
Gnome-säätiöiden avoimen lähdekoodin projektia. Heidän päätöspuihin perustuva
mallinsa luokitteli bugit 10-20\% sattumanvaraista arvausta paremmin.
Tutkimuksessa havaittiin ennusteen kannalta keskeisiksi muuttujiksi esimerkiksi
delegoitu kehittäjä ja avaamisen ajankohta. Avaamisen jälkeen muuttuvien
dynaamisten muuttujien mukaan ottaminen paransi mallin tarkkuutta. Mallin
heikkoutena voisi pitää sitä että opetus- ja testidataa ei oltu eroteltu
ajallisesti, eli mallissa oli tietoa "tulevaisuudesta" suhteessa testidataan.
Mallin käyttökelpoisuus uusien bugien korjausajan ennustamiseen ei siis ole
ollenkaan varmaa.

\textcite{Lamkanfi-2012} huomasivat epäilyttävän piirteen bugiseurantaohjelmista
saadusta datasta: suuri osa bugeista korjataan heti avaamisen jälkeen. He
selittivät tämän sillä, että joskus ohjelmistokehittäjät korjaavat löytämänsä
virheen ennen kuin sitä on ehditty raportoida. Kehittäjät sitten avaavat ja
sulkevat raportin samaan aikaan kuin tallentavat korjatun ohjelmakoodin. He
epäilivät, että nämä hyvin nopeasti suljetut raportit voivat hämmentää
koneoppimisalgorimeja ja esittivät hyvin nopeasti suljettujen bugien
suodattamista aineistosta. %
He käyttivät Naiivia Bayes-luokittelijaa ja vertailivat saadun mallin
suorituskyvyn muutosta, kun epäilyttävät bugit on poistettu aineistosta.
Tuloksena luokittelijan AUC-arvo parani jonkin verran suodatetulla datalla, ja
johtopäätöksenä voinee todeta, että kuten muussakin datanlouhinnassa, myös
Mining Software Repositories -kentällä poikkeavien havaintojen analysointi voi
tuottaa parempia tuloksia.


\textcite{Guo-2010} havaitsivat, että bugin raportoijan ja sitä ratkaisevan
kehittäjän  historia vaikuttavat raportoitujen bugien korjausaikaan. He laskivat
raportoijan "maineen"\ avattujen ja korjattujen bugiraporttien suhteena ja
totesivat tämän muuttujan parantavan luokittimen suorituskykyä.%
\textcite{Bhattacharya-2011} huomasivat ristiriidan \parencite{Guo-2010}
tutkimukseen, sillä he eivät avoimen lähdekoodin projekteissa havainneet
yhteyttä raportoijan "maineen"\ ja bugien korjausaikojen välillä. He
tarkastelivat myös muita muuttujia, joita on käytetty bugikorjauksen
valmistumisaikaa ennustavissa malleissa, ja huomasivat, että pieni määrä
muuttujia ei riitä selittämään ilmiötä. \parencite{Bhattacharya-2011}
Kehittäjäkohtaista pisteytystä on esittänyt myös \textcite{ramarao-2016}. Heidän
esittämänsä kaavan mukaan kehittäjän "maine" lasketaan hänen raportoimiensa jo
korjattujen bugien perusteella. Sen lisäksi pisteytyksen painoarvo suhteutetaan
projektikohtaisesti bugin korjausajan ennustamista varten.
\textcite{ramarao-2016} osoittivat pisteytyksen toimivuuden knn-pohjaisella
luokittimella.

%
% NOTE TO SELF: Käytä \textcite{Habayeb-2018}!
%

\textcite{Marks-2011} käyttivät Random Forest -algoritmia luodakseen tutkiakseen
aikaa bugin delegoinnista sen korjaamiseen. Tutkimuksen aineistona oli Eclipse-
ja Mozilla-projektien Bugzilla-tietokannat. Saadut mallit ennustivat korjausajan
n. 65\% tarkkuudella kolmeen luokkaan: kvartaalin, vuoden ja kolmen vuoden
sisällä korjattaviin. Tutkijat myös huomasivat, että parhaiten korjausaikaa
ennustavat muuttujat erosivat projektien välillä. Tämä antaa aihetta epäillä
sitä, kuinka tarkkaa mallia voi luoda, jos yleisesti hyvin toimivia muuttujia ei
löydy.

\textcite{Zhang-2013} tutkivat yhden ohjelmistoalan organisaation sisäisiä
projekteja, ja loivat kolme mallia estimoimaan eri näkökulmia bugien
korjausaikaan. Markovin ketjuihin perustuvalla mallilla he onnistuivat
luotettavasti ennustamaan tulevaisuudessa korjattavien ohjelmistovirheiden
lukumäärän. Monte Carlo -simulointiin perustuvalla metodilla he estimoivat
aikaa, joka kuluu annetun bugimäärän korjaamiseen. Luokittelemalla bugit
kNN-algoritmilla nopeasti ja hitaasti korjautuviin he myös onnistuivat
luokittelemaan yksittäisten bugien korjausaikoja (F-arvo 72.45\%). Tärkeänä
osana hyvän tuloksen saamista oli se, että tutkijat sovittivat mallinsa ottamaan
huomioon korjausaikojen jakauman, jossa suurin osa bugeista korjataan varsin
lyhyessä ajassa. Markovin ketjuja käyttivät myös \textcite{Pombo-2020}, joiden
kehittämä malli luokitteli bugit nopeasti ja hitaasti korjattaviksi
65.01-77.87\% tarkkuuten yltäen. Ylisovittumisesta johtuen malli sai parhaat
tulokset, kun opetus- ja testidataa oli saman verran.

\textcite{Pfahl-2016} toistivat usean aiemmin bugien tai tehtävätikettiin
kuluvan ajan ennustamiseen esitetyn koneoppimismenetelmän, ja vertasivat saatua
tarkkuutta samojen tikettien luomisessa annettuun asiantuntija-arvioon.
Pääsääntöisesti asiantuntija-arviot olivat tarkempia, mutta Random Forest
-algoritmiin ja logistiseen regressioon perustuvat mallit pääsivät varsin
lähelle. Tekstianalyysiin perustuva \textit{Spherical k-means Clustering} tuotti
jopa tarkempia arvioita kuin asiantunijat.

\textcite{Porru-2016} kehittivät käytännön ohjelmistokehitykseen sopivan mallin,
joka ennustaa tehtävälle annettavien \textit{story point} -pisteiden määrän.
Niillä kuvataan tehtävän vaativuutta, ei niinkään arvioitua työaikaa. Paras
luokitinmalli saatiin aikaan tukivektorikoneella. Keskeisenä elementtinä
piirteiden louhinnassa oli tekstianalyysi, mihin tukivektorikoneet sopivat
hyvin. Mallin opetukseen riitti noin 300 tehtävätikettiä. Tehtävät jakautuivat
\textit{story point} -pisteiden mukaan 13:n luokkaan ja mallin keskimääräinen
tarkkuus oli 64 \%. Tutkimuksen aineistona oli kahdeksan avoimen lähdekoodin
projektia ja yksi teollisuusprojekti.

Myöhemmin \textcite{Scott-2018} tulivat kuitenkin siihen tulokseen, että
\textit{story point} -pisteitä ennustettaessa kehittäjäkohtaisten ominaisuuksien
perusteella kehitetty tukivektorikone-pohjainen malli tuottaa parempia tuloksia
kuin tekstianalyysiin pohjaava. \textcite{Scott-2018} käyttivät samaa aineistoa,
kuin \textcite{Porru-2016}, mutta heidän tekstianalyysiin pohjaavan mallin
tarkkuus oli vain 35.8\%, mikä on ristiriidassa aiemman tutkimuksen tulosten
kanssa. Koska myös kehittäjäkohtaisten ominaisuuksien vaikutuksesta tehtävien
valmistumisaikaan on ristiriitaisia tuloksia, vahvistavat nämä tutkimukset sitä
näkemystä, että myöskään bugin korjausajan ennustamista ei voida yksinkertaistaa
vain muutamaan muuttujaan.

\textcite{Ardimento-2017} käyttivät myös tukivektorikoneita mallissa, joka
ennustaa bugeja nopeasti tai hitaasti korjattavaiksi sen tiedon perusteella,
jota on käytettävissä tiketin avaushetkellä. Aineisona käytettiin kolmea avoimen
lähdekoodin projektia. Malli luokitteli bugitiketit nopeiksi 35-52\%
tarkkuudella, ja sen herkkyys (\textit{recall}) oli 60-76\%.

\textcite{Ardimento-2016} lähestyivät samaa ennustustehtävää hyödyntämällä
SLDA-tekstinlouhinta-algoritmia. SLDA-algoritmin avulla he pyrkivät erottelemaan
jokaisen bugiraportin kuvauksesta useampia ala-aiheita, jotka voisivat selittää
paremmin bugien korjausaikaa. He painottivat malliaan tunnistamaan erityisesti
hitaasti korjattavat bugit. Aineistona heillä oli avoimen lähdekoodin Eclipse-,
Gentoo-, KDE- ja OpenOffice-projektit. Painotuksen vuoksi mallin tarkkuus jäi
alle tukivektorikoneen, mutta se tunnisti useimmat hitaasti korjattavat bugit.

\textcite{Al-Zubaidi-2017} käyttivät evoluutioalgoritmia tehtävän ratkaisemiseen
kuluvaa aikaa ennustavan mallin kehittämiseksi. Tavoitteena tehdä ennusteita
sillä tiedolla, jota on käytettävissä tiketin avaushetkellä. Tutkimuksen
lähdeaineistona oli viisi Apache-järjestön avoimen lähdekoodin projektia.
Kyseisellä aineistolla evoluutioalgoritmi tuotti paremman mallin kuin
lineaariseen regressioon, kNN-algoritmi tai Random Forest -algoritmi. Mallin
etuna useisiin muihin voinee pitää sitä, että luokitteluasteikollisten
aikaikkunoiden sijaan ennusteet ovat jatkuva-asteikollisia.
%,Ardimento-2020,Lee-2020, ramarao-2016}

\textcite{Sharma-2019} tutkivat bugien korjausaikojen sekä vakavuuden
ennustamista ja vertailivat useita koneoppimisalgoritmeja. Korjausaikoja
onnistuttiin ennustamaan parhaiten tukivektoriregressiomallilla, jolla
\(R^2\)-arvoksi saatiin yli 0.9. Muita käytettyjä algoritmeja olivat lineaarinen
regressio, sumea regressio ja kNN-regressio. Varsin mielenkiintoisena tuloksena
heidän aineistossaan bugiraporttien kuvauksista tf-ifd -menetelmällä lasketut
painoarvot eivät parantaneet mallien tuloksia. Aineistona he käyttivät kahdeksaa
Mozilla-säätiön ohjelmistoprojektia.

\textcite{Lee-2020} kehittivät syväoppimiseen perustuvan mallin, joka hyödynsi
bugin korjausaikana syntyvää dynaamista dataa sen korjausajan ennustamiseksi.
Seitsemään luokkaan (aikaikkunaan) opetettuna  mallin tarkkuus oli 23.5-24.9\%
(top-2 tarkkuus 39.9-50.1\%). Datan he olivat keränneet Firefox-, Chromium- ja
Eclipse-projektien bugiraportointijärjestelmistä. Heidän mallinsa on ainoa tähän
mennessä julkaistu syväoppimiseen perustuva bugien korjausaikoja ennustava
järjestelmä.

\chapter{Tutkimusaihe/tutkimuskysymys}
Tutkimuksen tavoitteena on tuottaa lisää tietoa siitä, kuinka bugi-raportin
ratkeamisaikaa voidaan ennustaa käyttäen hyväksi tiedon louhimisen menetelmiä.
Pyrin käyttämään hyväksi aiemmassa tutkimuksessa \parencite{riivo-2016} melko
hyväksi todettua mallia ja dataa, ja testaamaan voiko mallia parantaa ottamalla
huomioon muissa tutkimuksissa tehtyjä havaintoja. Tutkimuksen tulosten avulla
voi tehdä arvioita siitä, kuinka kypsä tutkimussuunta on käytännön sovellusten
kannalta, ja mihin suuntaan huomio kannattaisi kiinnittää mallien kehittämisen
kannalta.

% Kilpailevat päämäärät: halutaanko tunnistaa hitaat vai nopeat bugit?
% Pienempien aineistojen ongelma, tarttuuko liiaksi yhden organisaation
% prosessiin?
\chapter{Aineisto ja metodi}
Tutkimusprosessin alussa on tarkoitus perehtyä syvällisesti käytettyyn malliin
\parencite{riivo-2016}, jotta tutkijalle syntyy sen tarjoamista
mahdollisuuksista ja rajoista. Tärkeää on tietää esimerkiksi, onko lähtödatan
käsittelyprosessi toistettavissa, ja millaisilla muuttujilla mallia on
mahdollista laajentaa. Sen lisäksi alussa on myös kerättävä mahdollisimman hyvin
kaikki aihetta käsittelevät tutkimukset. Kerättyjen tutkimusten perusteella
voidaan tehdä perusteltu valinta siitä, mitkä ovat potentiaalisimpia
vaihtoehtoja mallin kehittämiseksi.

Tämän jälkeen valittu/valitut muutokset toteutetaan ohjelmakoodiin ja
käytettävyyn dataan, sekä verrataan saadun uuden mallin tuloksia aiempiin
tutkimuksiin. Saadut tulokset ovat luonteeltaan kvantitatiivisia.

Tutkimusen kokeellinen osuus on siis luonteeltaan tiedonlouhimis- ja
koneoppimistehtävä.

\section{Aineisto}
Tutkimuksen aineisona on GHTorrent-projektin \footnote{https://ghtorrent.org/}
\parencite{Gousi13} keräämä relaatiotietokanta GitHub-palveluun tallennetuista
avoimesti saatavilla olevista projekteista. Tietokantaan on tallennettu
projekteihin liittyen tuote- ja prosessidataa; projekteista on kerätty muun
muassa tiedot versiohistoriaa kuvaavista commit-tapahtumista, kehittäjien
luomista pull request -muutosehdotuksista ja kaikkien käyttäjien luomista
issue-ketjuista. Issues on GitHubin keskustelupohjainen työkalu, mikä soveltuu
tehtävienhallintaan ja bugien seurantaan.

GHTorrent-tietokantaan kerätty data on peräisin GitHubin tarjoamasta
REST-ohjelmointirajapinnasta \footnote{https://docs.github.com/en/rest}
\parencite{Gousi13}. GHTorrent-aineiston suurimpana etuna voi pitää sen suurta
kokoa ja heterogeenisyyttä. GitHub on vakiinnuttanut asemansa suosituimpana
alustana avoimen lähdekoodin projektien hallintaan, joten sieltä kerätyn tiedon
voisi olettaa edustavan hyvin kattavaa kuvaa avoimen lähdekoodin projekteihin
liittyvistä ilmiöistä, kuten kehittäjien yhteistyöstä, ohjelmistojen
elinkaaresta ja niiden laajuudesta. Useimmat bugien korjausaikaa ennustavat
mallit ovat opetettu ja testattu alle kymmenen suuren ohjelmiston
bugiseurantajärjestelmästä saadulla datalla. GitHubissa taas eri kokoisia
repositorioita on miljoonia. Yksi haaste GitHubista kerätyssä datassa verrattuna
varsinaisista buginseurantaohjelmista kerättyyn dataan on se, että GitHubin
Issues-ominaisuus jättää varsin vapaat kädet bugien käsittelyprosessille. Issues
ei myöskään rajoitu vain bugien seurantaan, vaan sitä käytetään muidenkin
ohjelmistoprojektin tehtävien hallintaan. Eri tyyppisiä tehtäviä voi erotella
niihin liitettävillä nimikkeilä (\textit{label}), ja yksi GitHubin tarjoamista
vakionimikkeistä onkin "Bug". Projekteilla on kuitenkin mahdollisuus kustomoida
käytettäviä nimikkeitä omien tarpeidensa mukaan esimerkiksi hienosyisempään
bugien jaotteluun tai erilaisten tehtävien kuvaamiseksi. Nimikkeiden käyttö ei
myöskään ole pakollista, jolloin voi olla mahdotonta selvittää onko jokin
tehtävä avattu bugin korjausta vai jotain muuta kehitystyötä varten.
Projekteilla on vaihtelevia buginkorjausprosesseja, ja niiden kulkua ei
välttämättä pysty seuraamaan pelkästään GitHubista löytyvän datan perusteella.
Siksi lienee hyvin vaikeaa antaa yleistä kaaviota siitä, mitä tapahtuu
bugiraportin avaamisen ja sen sulkemisen välillä. Esimerkiksi
Bugzilla-järjestelmässä bugeilla ja niiden käsittelyllä on yksiselitteisempi
vuokaavio.

\begin{verbatim}
Tähän aineiston numeerista kuvausta, käsittelyn/filtteroinnin 
kuvaus, sekä vertailu muihin käytettyihin aineistoihin.
\end{verbatim}

%  Miksi ei vaan itse keräis tätä samaa dataa?


% Tutkimuksen aineistonhankinta jäljittelee aiempaa tutkimusta
% \parencite{riivo-2016}, laajentaen sitä päivitetyllä datalla.
% oheismateriaalina julkaistu data ja lähdekoodi. Alkuperäinen data on saatu
% GHTorrent-projektin \parencite{Gousi13} keräämän datasetin pohjalta.
% GHTorrent-projekti kerää julkisesti saatavilla olevaa dataa Github-palvelusta
% löytyvistä projekteista. %Lähteitä? Projektiin kerättyä dataa on käytetty
% aiemmin useissa tutkimuksissa. Datasta on poistettu käyttäjänimet ja
% sähköpostiosoitteet tietosuoja-asetusten johdosta.

% Jos tarpeellista ja mahdollista, voi olemassa olevaa aineistoa laajentaa
% käyttämällä hyväksi GHTorrentin tarjoamaa dataa. Alkuperäisessä aineistossa on
% dataa noin kahden vuoden ajalta, kun nykyään projektissa on dataa kuuden
% vuoden ajalta.

% ALkuperäiseen lähdekoodiin ei ole liitetty mitään tekijänoikeuslisenssiä,
% joten lupa koodin uudelleenkäyttöön ja muokkaamiseen kysyttiin
% henkilökohtaisesti sähköpostitse.

% - mitä, keneltä, milloin, miten
% - ml. eettiset näkökohdat (hyvä tieteellinen käytäntö jota noudatetaan,
%   tietosuoja, tieteellisen tutkimuksen rekisteriseloste)
% - kuvaa konkreetilla tasolla miten ja milloin aineisto kerätään, käsitellään,
%   talletetaan, arkistoidaan/hävitetään
% - Aikataulu! \chapter{Aineiston analyysi} 
% - analyysin kuvaus, millä menetelmällä analyysi tehdään

\chapter{Tulokset}
\chapter{Johtopäätökset}
\printbibliography
\end{document}
