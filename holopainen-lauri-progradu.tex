\documentclass[utf8]{gradu3}
\usepackage{graphicx} % kuvien mukaan ottamista varten
\usepackage{amsmath} % hyödyllinen jos tekstisi sisältää matikkaa,
                     % ei pakollinen
\usepackage{booktabs} % hyvä kauniiden taulukoiden tekemiseen

% HUOM! Tämän tulee olla viimeinen \usepackage koko dokumentissa!
\usepackage[bookmarksopen,bookmarksnumbered,linktocpage]{hyperref}

\addbibresource{pro-gradu.bib} % Lähdetietokannan tiedostonimi

\begin{document}

\title{Avoimen lähdekoodin projektien ohjelmistovirheiden korjausajan arviointi tiedonlouhimismenetelmin}
\translatedtitle{Pro Gradu (to be\dots)}
\studyline{Ohjelmistotekniikka} \avainsanat{} \keywords{} 
\tiivistelma{Tiivistelmä}
\abstract{}

\author{Lauri Holopainen}
\contactinformation{\texttt{lauri.m.s.holopainen@jyu.fi}}
% jos useita tekijöitä, anna useampi \author-komento 
\supervisor{Ville Isomöttönen}
% jos useita ohjaajia, anna useampi \supervisor-komento

\maketitle

\mainmatter

\chapter{Johdanto}
% - Bugit
%   * Käytännön tärkeys.
%   * Tieteellinen merkitys.
Ohjelmistokehityksen ja  ja ohjelmistojen ylläpidon keskeisiä ongelmia ovat
ohjelmointivirheet eli bugit. Mitä myöhemmässä vaiheessa bugit huomataan, sitä
enemmän resursseja, siis työaikaa, voi olettaa kuluvan niiden korjaamiseen. Olen
kiinnostunut siitä, kuinka bugikorjauksiin kuluvaa aikaa voisi arvioida
matemaattisten mallien avulla. Tutkielmassani aion selvittää, voisiko nyt jo
kehitettyjä malleja muuttaa tarkemmiksi tuomalla samaan malliin parhaita
piirteitä useista tutkimuksista.

Modernissa ketterässä ohjelmistokehitystyössä hyödynnetään usein erilaisia
tikettijärjestelmiä bugien ja kehitysideoiden raportointiin. Tiketit voivat
saada alkunsa niin loppukäyttäjien, kuin kehittäjäorganisaation huomioista. Kun
tiketin vastaanottaja kuittaa tehtävän työn alle, hän arvioi tarvittavan
ohjelmistomuutoksen kriittisyyden, nimittää sen jollekin kehittäjälle, ja arvioi
siihen kuluvan ajan. Kuluvan ajan sijaan voidaan myös arvioida tehtävän
haasteellisuutta (\textit{story points}). Onnistunut tehtävän vaatiman ajan
arviointi voi auttaa kehitysprojektin vetäjiä suunnittelemaan aikataulun
suunnittelussa ja resurssien suuntaamisessa. Loppukäyttäjiä hyvät
korjausaika-arviot voivat myös hyödyttää esimerkiksi oman työnsä suunnittelussa
tai sen arvioinnissa, että onko järkevää jäädä odottamaan korjauksen
valmistumista.

Bugikorjausten valmistumisaikaa on yritetty arvioida louhimalla tietoa
tikettijärjestelmiä, ja luomalla tilastollisia malleja muun muassa koneoppimisen
avulla. Yksi käytetyimpiä mittareita on aika tiketin avaamisesta sen
sulkeutumiseen. Tutkimuksissa saadut tulokset ovat kuitenkin olleet välillä
ristiriitaisia, eivätkä aina kovinkaan tarkkoja. Vaikuttaisi siis siltä, että
lisätutkimuselle on tarvetta mikäli näitä malleja halutaan soveltaa käytännössä
osana.

\chapter{Ohjelmistokehitys avoimen lähdekoodin projekteissa}
\begin{itemize}
  \item Ohjelmistokehitys / OSS-projektit
  \item GitHub / Git
  \item Elinkaari / Ylläpito
\end{itemize}

\section{Bugien seuranta}
\begin{itemize}
  \item Bugit
  \item Raportointi - Korjaus
\end{itemize}
  
\chapter{Tiedonlouhinta ja koneoppiminen}
% - Tiedonlouhinta
%   * Menetelmät, arviointi.
% - Tekstin prosessointi tiedonlouhinnassa.
% - Mining software repositories Issue resolution time/bug fixing time
%   estimation.

% Projektikohtiaset vs. yleistettävät featuret?
Moderni yhteiskunta tuottaa ja tallentaa dataa jatkuvalla virralla. Pelkkä data
itsessään ei vielä ole tietoa tai tietämystä. Jotta siitä saataisiin
ymmärretäävää ja kiteytynyttä tietoa, se vaatii tulkintaa ja yhdistämistä muuhun
ympäristössä olevaan tietoon. % Pitäiskö keksiä jotain omaperäisempää :D
Informaatiojärjestelmiin kerättyä, ja niiden itse
keräämää, dataa on usein niin paljon, ettei sitä ole mahdollista käsitellä
manuaalisin menetelmin (ääriesimerkkinä Big data). Tiedonlouhinnan voi
määritellä oleellisen tiedon ja kiinnostavien kaavojen löytämiseksi suuresta
datamassasta \parencite[][8]{han-data_mining}. Alalla käytetään monenlaisia
tilastotieteen, matematiikan ja tietojenkäsittelyn tekniikoita
\parencite{clifton-2019}. 

Ohjelmistokehityksessä hyödynnetään usein hajautettuja
versiohallintajärjestelmiä kuten Git, sekä internet-palveluja kuten Github ja
Bitbucket tietovarastojen (\textit{repository}) hallintaan. Nämä palvelut
tarjoavat usein lähdekoodin jakamisen lisäksi myös muita ominaisuuksia, kuten
jatkuvan integraation kanavan, pull requestit, ja bugiraportit. Mining software
repositories (MSR) on tiedonlouhinnan osa-alue, joka on erikoistunut
ohjelmistokehityksessä syntyvän strukturoidun ja tekstimuotoisen datan
käsittelyyn. Tutkimuksen kohteita ovat esimerkiksi koodin mätäneminen, muutosten
riippuvuus, bugien ennakointi ja syyt, sekä kehittäjien yhteistyö.
\parencite{guemes-pena-emerging_topics}

\section{Tekstin prosessointi tiedonlouhinnassa}
 \begin{itemize}
   \item Stemmaus
   \item TF-IDF
   \item Haasteet
 \end{itemize}
\section{Random tree ja Random Forest}
\begin{itemize}
  \item Algoritmien kuvaus
  \item Arviointi
  \item Toimivuus aiemmissa sovelluksissa
\end{itemize}

\section{Bugien korjausajan arviointi}

% Motivaatio koneavusteisen korjausajan arvioinnin olemassaololle. Käytännön
% syyt.
% * kustannusten arvionti
% * delegointi
% * loppukäyttäjien tarpeet
% * muiden ohjelmistojen riippuvuudet
% * sisäisten ja ulkoisten tarpeiden tyydyttäminen hyvissä ajoin? Tieteelliset
%   syyt.

\subsection{Aiemmat koneoppimiseen perustuvat mallit}
Malleja ohjelmistobugien korjausajan arviointiin on kehitetty useissa
tutkimuksissa 2010-luvulla. Dataa on kerätty niin avoimen kuin suljetun
lähdekoodin projekteista. Näistä valtaosa on julkaistu konfferenssipapereina.
Joistakin löytyy myös pidempi artikkelimuotoinen teksti. Kirjallisuutta on
löytynyt eniten ACM DL ja IEEE -tietokannoista, sekä seuraamalla viitteitä
snowballing-tekniikalla. Tutkimukset eroavat muun muassa mallin kehityksessä
käytettyjen projektien määrässä, hyödynnetyissä attribuuteissa ja
koneoppimisalgoritmeissa.

\textcite{Anh-2011} tutkivat kehittäjäkohtaisten attribuuttien merkitystä bugien
korjausaikojen suhteen. Vahvimpana havaintona he huomasivat kehittäjän aiemmin
korjaamien bugien korjausaikojen keskiarvon olevan potentiaalinen muuttuja,
jonka mukaan ottaminen paransi koneoppimisalgoritmin tuottaman mallin tarkkutta
2.87-12.07\%.

\textcite{Giger-2010} tutkivat bugien luokittelua hitaasti ja nopeasti
ratkaistaviin. Aineistona he käyttivät kuutta Eclipse-, Mozilla- ja
Gnome-säätiöiden avoimen lähdekoodin projektia. Heidän päätöspuihin perustuva
mallinsa luokitteli bugit 10-20\% sattumanvaraista arvausta paremmin.
Tutkimuksessa havaittiin ennusteen kannalta keskeisiksi muuttujiksi esimerkiksi
delegoitu kehittäjä ja avaamisen ajankohta. Avaamisen jälkeen muuttuvien
dynaamisten muuttujien mukaan ottaminen paransi mallin tarkkuutta. Mallin
heikkoutena voisi pitää sitä että opetus- ja testidataa ei oltu eroteltu
ajallisesti, eli mallissa oli tietoa "tulevaisuudesta" suhteessa testidataan.
Mallin käyttökelpoisuus uusien bugien korjausajan ennustamiseen ei siis ole
ollenkaan varmaa.

\textcite{Lamkanfi-2012} huomasivat epäilyttävän piirteen bugiseurantaohjelmista
saadusta datasta: suuri osa bugeista korjataan heti avaamisen jälkeen. He
selittivät tämän sillä, että joskus ohjelmistokehittäjät korjaavat löytämänsä
virheen ennen kuin sitä on ehditty raportoida. Kehittäjät sitten avaavat ja
sulkevat raportin samaan aikaan kuin tallentavat korjatun ohjelmakoodin. He
epäilivät, että nämä hyvin nopeasti suljetut raportit voivat hämmentää
koneoppimisalgorimeja ja esittivät hyvin nopeasti suljettujen bugien
suodattamista aineistosta. %
He käyttivät Naiivia Bayes-luokittelijaa ja vertailivat saadun mallin
suorituskyvyn muutosta, kun epäilyttävät bugit on poistettu aineistosta.
Tuloksena luokittelijan AUC-arvo parani jonkin verran suodatetulla datalla, ja
johtopäätöksenä voinee todeta, että kuten muussakin datanlouhinnassa, myös
Mining Software Repositories -kentällä poikkeavien havaintojen analysointi voi
tuottaa parempia tuloksia.
 

\textcite{Guo-2010} havaitsivat, että bugin raportoijan ja sitä ratkaisevan
kehittäjän  historia vaikuttavat raportoitujen bugien korjausaikaan. He laskivat
raportoijan "maineen"\ avattujen ja korjattujen bugiraporttien suhteena ja
totesivat tämän muuttujan parantavan luokittimen suorituskykyä.%
\textcite{Bhattacharya-2011} huomasivat ristiriidan \parencite{Guo-2010}
tutkimukseen, sillä he eivät avoimen lähdekoodin projekteissa havainneet
yhteyttä raportoijan "maineen"\ ja bugien korjausaikojen välillä. He
tarkastelivat myös muita muuttujia, joita on käytetty bugikorjauksen
valmistumisaikaa ennustavissa malleissa, ja huomasivat, että pieni määrä
muuttujia ei riitä selittämään ilmiötä. \parencite{Bhattacharya-2011}
Kehittäjäkohtaista pisteytystä on esittänyt myös \textcite{ramarao-2016}. Heidän
esittämänsä kaavan mukaan kehittäjän "maine" lasketaan hänen raportoimiensa jo
korjattujen bugien perusteella. Sen lisäksi pisteytyksen painoarvo suhteutetaan
projektikohtaisesti bugin korjausajan ennustamista varten.
\textcite{ramarao-2016} osoittivat pisteytyksen toimivuuden knn-pohjaisella
luokittimella.

%
% NOTE TO SELF: Käytä \textcite{Habayeb-2018}!
%

\textcite{Marks-2011} käyttivät Random Forest -algoritmia luodakseen tutkiakseen
aikaa bugin delegoinnista sen korjaamiseen. Tutkimuksen aineistona oli Eclipse-
ja Mozilla-projektien Bugzilla-tietokannat. Saadut mallit ennustivat korjausajan
n. 65\% tarkkuudella kolmeen luokkaan: kvartaalin, vuoden ja kolmen vuoden
sisällä korjattaviin. Tutkijat myös huomasivat, että parhaiten korjausaikaa
ennustavat muuttujat erosivat projektien välillä. Tämä antaa aihetta epäillä
sitä, kuinka tarkkaa mallia voi luoda, jos yleisesti hyvin toimivia muuttujia ei
löydy.

\textcite{Zhang-2013} tutkivat yhden ohjelmistoalan organisaation sisäisiä
projekteja, ja loivat kolme mallia estimoimaan eri näkökulmia bugien
korjausaikaan. Markovin ketjuihin perustuvalla mallilla he onnistuivat
luotettavasti ennustamaan tulevaisuudessa korjattavien ohjelmistovirheiden
lukumäärän. Monte Carlo -simulointiin perustuvalla metodilla he estimoivat
aikaa, joka kuluu annetun bugimäärän korjaamiseen. Luokittelemalla bugit
kNN-algoritmilla nopeasti ja hitaasti korjautuviin he myös onnistuivat
luokittelemaan yksittäisten bugien korjausaikoja (F-arvo 72.45\%). Tärkeänä
osana hyvän tuloksen saamista oli se, että tutkijat sovittivat mallinsa ottamaan
huomioon korjausaikojen jakauman, jossa suurin osa bugeista korjataan varsin
lyhyessä ajassa. Markovin ketjuja käyttivät myös \textcite{Pombo-2020}, joiden
kehittämä malli luokitteli bugit nopeasti ja hitaasti korjattaviksi
65.01-77.87\% tarkkuuten yltäen. Ylisovittumisesta johtuen malli sai parhaat
tulokset, kun opetus- ja testidataa oli saman verran.

\textcite{Pfahl-2016} toistivat usean aiemmin bugien tai tehtävätikettiin
kuluvan ajan ennustamiseen esitetyn koneoppimismenetelmän, ja vertasivat saatua
tarkkuutta samojen tikettien luomisessa annettuun asiantuntija-arvioon.
Pääsääntöisesti asiantuntija-arviot olivat tarkempia, mutta Random Forest
-algoritmiin ja logistiseen regressioon perustuvat mallit pääsivät varsin
lähelle. Tekstianalyysiin perustuva \textit{Spherical k-means Clustering} tuotti
jopa tarkempia arvioita kuin asiantunijat.

\textcite{Porru-2016} kehittivät käytännön ohjelmistokehitykseen sopivan mallin,
joka ennustaa tehtävälle annettavien \textit{story point} -pisteiden määrän.
Niillä kuvataan tehtävän vaativuutta, ei niinkään arvioitua työaikaa. Paras
luokitinmalli saatiin aikaan tukivektorikoneella. Keskeisenä elementtinä
piirteiden louhinnassa oli tekstianalyysi, mihin tukivektorikoneet sopivat
hyvin. Mallin opetukseen riitti noin 300 tehtävätikettiä. Tehtävät jakautuivat
\textit{story point} -pisteiden mukaan 13:n luokkaan ja mallin keskimääräinen
tarkkuus oli 64 \%. Tutkimuksen aineistona oli kahdeksan avoimen lähdekoodin
projektia ja yksi teollisuusprojekti.

Myöhemmin \textcite{Scott-2018} tulivat kuitenkin siihen tulokseen, että
\textit{story point} -pisteitä ennustettaessa kehittäjäkohtaisten ominaisuuksien
perusteella kehitetty tukivektorikone-pohjainen malli tuottaa parempia tuloksia
kuin tekstianalyysiin pohjaava. \textcite{Scott-2018} käyttivät samaa aineistoa,
kuin \textcite{Porru-2016}, mutta heidän tekstianalyysiin pohjaavan mallin
tarkkuus oli vain 35.8\%, mikä on ristiriidassa aiemman tutkimuksen tulosten
kanssa. Koska myös kehittäjäkohtaisten ominaisuuksien vaikutuksesta tehtävien
valmistumisaikaan on ristiriitaisia tuloksia, vahvistavat nämä tutkimukset sitä
näkemystä, että myöskään bugin korjausajan ennustamista ei voida yksinkertaistaa
vain muutamaan muuttujaan.

\textcite{Ardimento-2017} käyttivät myös tukivektorikoneita mallissa, joka
ennustaa bugeja nopeasti tai hitaasti korjattavaiksi sen tiedon perusteella,
jota on käytettävissä tiketin avaushetkellä. Aineisona käytettiin kolmea avoimen
lähdekoodin projektia. Malli luokitteli bugitiketit nopeiksi 35-52\%
tarkkuudella, ja sen herkkyys (\textit{recall}) oli 60-76\%. 

\textcite{Ardimento-2016} lähestyivät samaa ennustustehtävää hyödyntämällä
SLDA-tekstinlouhinta-algoritmia. SLDA-algoritmin avulla he pyrkivät erottelemaan
jokaisen bugiraportin kuvauksesta useampia ala-aiheita, jotka voisivat selittää
paremmin bugien korjausaikaa. He painottivat malliaan tunnistamaan erityisesti
hitaasti korjattavat bugit. Aineistona heillä oli avoimen lähdekoodin Eclipse-,
Gentoo-, KDE- ja OpenOffice-projektit. Painotuksen vuoksi mallin tarkkuus jäi
alle tukivektorikoneen, mutta se tunnisti useimmat hitaasti korjattavat bugit.

\textcite{Al-Zubaidi-2017} käyttivät evoluutioalgoritmia tehtävän ratkaisemiseen
kuluvaa aikaa ennustavan mallin kehittämiseksi. Tavoitteena tehdä ennusteita
sillä tiedolla, jota on käytettävissä tiketin avaushetkellä. Tutkimuksen
lähdeaineistona oli viisi Apache-järjestön avoimen lähdekoodin projektia.
Kyseisellä aineistolla evoluutioalgoritmi tuotti paremman mallin kuin
lineaariseen regressioon, kNN-algoritmi tai Random Forest -algoritmi. Mallin
etuna useisiin muihin voinee pitää sitä, että luokitteluasteikollisten
aikaikkunoiden sijaan ennusteet ovat jatkuva-asteikollisia.
%,Ardimento-2020,Lee-2020, ramarao-2016}

\textcite{Sharma-2019} tutkivat bugien korjausaikojen sekä vakavuuden
ennustamista ja vertailivat useita koneoppimisalgoritmeja. Korjausaikoja
onnistuttiin ennustamaan parhaiten tukivektoriregressiomallilla, jolla
\(R^2\)-arvoksi saatiin yli 0.9. Muita käytettyjä algoritmeja olivat lineaarinen
regressio, sumea regressio ja kNN-regressio. Varsin mielenkiintoisena tuloksena
heidän aineistossaan bugiraporttien kuvauksista tf-ifd -menetelmällä lasketut
painoarvot eivät parantaneet mallien tuloksia. Aineistona he käyttivät kahdeksaa
Mozilla-säätiön ohjelmistoprojektia.

\textcite{Lee-2020} kehittivät syväoppimiseen perustuvan mallin, joka hyödynsi
bugin korjausaikana syntyvää dynaamista dataa sen korjausajan ennustamiseksi.
Seitsemään luokkaan (aikaikkunaan) opetettuna  mallin tarkkuus oli 23.5-24.9\%
(top-2 tarkkuus 39.9-50.1\%). Datan he olivat keränneet Firefox-, Chromium- ja
Eclipse-projektien bugiraportointijärjestelmistä. Heidän mallinsa on ainoa tähän
mennessä julkaistu syväoppimiseen perustuva bugien korjausaikoja ennustava
järjestelmä.

\chapter{Tutkimusaihe/tutkimuskysymys}
Tutkimuksen tavoitteena on tuottaa lisää tietoa siitä, kuinka bugi-raportin
ratkeamisaikaa voidaan ennustaa käyttäen hyväksi tiedon louhimisen menetelmiä.
Pyrin käyttämään hyväksi aiemmassa tutkimuksessa \parencite{riivo-2016} melko
hyväksi todettua mallia ja dataa, ja testaamaan voiko mallia parantaa ottamalla
huomioon muissa tutkimuksissa tehtyjä havaintoja. Tutkimuksen tulosten avulla
voi tehdä arvioita siitä, kuinka kypsä tutkimussuunta on käytännön sovellusten
kannalta, ja mihin suuntaan huomio kannattaisi kiinnittää mallien kehittämisen
kannalta.

% Kilpailevat päämäärät: halutaanko tunnistaa hitaat vai nopeat bugit?
% Pienempien aineistojen ongelma, tarttuuko liiaksi yhden organisaation
% prosessiin?
\chapter{Aineisto ja metodi}
Tutkimusprosessin alussa on tarkoitus perehtyä syvällisesti käytettyyn malliin
\parencite{riivo-2016}, jotta tutkijalle syntyy sen tarjoamista
mahdollisuuksista ja rajoista. Tärkeää on tietää esimerkiksi, onko lähtödatan
käsittelyprosessi toistettavissa, ja millaisilla muuttujilla mallia on
mahdollista laajentaa. Sen lisäksi alussa on myös kerättävä mahdollisimman hyvin
kaikki aihetta käsittelevät tutkimukset. Kerättyjen tutkimusten perusteella
voidaan tehdä perusteltu valinta siitä, mitkä ovat potentiaalisimpia
vaihtoehtoja mallin kehittämiseksi.

Tämän jälkeen valittu/valitut muutokset toteutetaan ohjelmakoodiin ja
käytettävyyn dataan, sekä verrataan saadun uuden mallin tuloksia aiempiin
tutkimuksiin. Saadut tulokset ovat luonteeltaan kvantitatiivisia. 

Tutkimusen kokeellinen osuus on siis luonteeltaan tiedonlouhimis- ja
koneoppimistehtävä.

\section{Aineisto}
Tutkimuksen aineisona on GHTorrent-projektin \footnote{https://ghtorrent.org/}
\parencite{Gousi13} keräämä relaatiotietokanta GitHub-palveluun tallennetuista
avoimesti saatavilla olevista projekteista. Tietokantaan on tallennettu
projekteihin liittyen tuote- ja prosessidataa; projekteista on kerätty muun
muassa tiedot versiohistoriaa kuvaavista commit-tapahtumista, kehittäjien
luomista pull request -muutosehdotuksista ja kaikkien käyttäjien luomista
issue-ketjuista. Issues on GitHubin keskustelupohjainen työkalu, mikä soveltuu
tehtävienhallintaan ja bugien seurantaan.

GHTorrent-tietokantaan kerätty data on peräisin GitHubin tarjoamasta
REST-ohjelmointirajapinnasta \footnote{https://docs.github.com/en/rest}
\parencite{Gousi13}. GHTorrent-aineiston suurimpana etuna voi pitää sen suurta
kokoa ja heterogeenisyyttä. GitHub on vakiinnuttanut asemansa suosituimpana
alustana avoimen lähdekoodin projektien hallintaan, joten sieltä kerätyn tiedon
voisi olettaa edustavan hyvin kattavaa kuvaa avoimen lähdekoodin projekteihin
liittyvistä ilmiöistä, kuten kehittäjien yhteistyöstä, ohjelmistojen
elinkaaresta ja niiden laajuudesta. Useimmat bugien korjausaikaa ennustavat
mallit ovat opetettu ja testattu alle kymmenen suuren ohjelmiston
bugiseurantajärjestelmästä saadulla datalla. GitHubissa taas eri kokoisia
repositorioita on miljoonia. Yksi haaste GitHubista kerätyssä datassa verrattuna
varsinaisista buginseurantaohjelmista kerättyyn dataan on se, että GitHubin
Issues-ominaisuus jättää varsin vapaat kädet bugien käsittelyprosessille. Issues
ei myöskään rajoitu vain bugien seurantaan, vaan sitä käytetään muidenkin
ohjelmistoprojektin tehtävien hallintaan. Eri tyyppisiä tehtäviä voi erotella
niihin liitettävillä nimikkeilä (\textit{label}), ja yksi GitHubin tarjoamista
vakionimikkeistä onkin "Bug". Projekteilla on kuitenkin mahdollisuus kustomoida
käytettäviä nimikkeitä omien tarpeidensa mukaan esimerkiksi hienosyisempään
bugien jaotteluun tai erilaisten tehtävien kuvaamiseksi. Nimikkeiden käyttö ei
myöskään ole pakollista, jolloin voi olla mahdotonta selvittää onko jokin
tehtävä avattu bugin korjausta vai jotain muuta kehitystyötä varten.
Projekteilla on vaihtelevia buginkorjausprosesseja, ja niiden kulkua ei
välttämättä pysty seuraamaan pelkästään GitHubista löytyvän datan perusteella.
Siksi lienee hyvin vaikeaa antaa yleistä kaaviota siitä, mitä tapahtuu
bugiraportin avaamisen ja sen sulkemisen välillä. Esimerkiksi
Bugzilla-järjestelmässä bugeilla ja niiden käsittelyllä on yksiselitteisempi
vuokaavio.

\begin{verbatim}
Tähän aineiston numeerista kuvausta, käsittelyn/filtteroinnin 
kuvaus, sekä vertailu muihin käytettyihin aineistoihin.
\end{verbatim}

%  Miksi ei vaan itse keräis tätä samaa dataa?


% Tutkimuksen aineistonhankinta jäljittelee aiempaa tutkimusta
% \parencite{riivo-2016}, laajentaen sitä päivitetyllä datalla.
% oheismateriaalina julkaistu data ja lähdekoodi. Alkuperäinen data on saatu
% GHTorrent-projektin \parencite{Gousi13} keräämän datasetin pohjalta.
% GHTorrent-projekti kerää julkisesti saatavilla olevaa dataa Github-palvelusta
% löytyvistä projekteista. %Lähteitä? Projektiin kerättyä dataa on käytetty
% aiemmin useissa tutkimuksissa. Datasta on poistettu käyttäjänimet ja
% sähköpostiosoitteet tietosuoja-asetusten johdosta.

% Jos tarpeellista ja mahdollista, voi olemassa olevaa aineistoa laajentaa
% käyttämällä hyväksi GHTorrentin tarjoamaa dataa. Alkuperäisessä aineistossa on
% dataa noin kahden vuoden ajalta, kun nykyään projektissa on dataa kuuden
% vuoden ajalta.

% ALkuperäiseen lähdekoodiin ei ole liitetty mitään tekijänoikeuslisenssiä,
% joten lupa koodin uudelleenkäyttöön ja muokkaamiseen kysyttiin
% henkilökohtaisesti sähköpostitse.

% - mitä, keneltä, milloin, miten
% - ml. eettiset näkökohdat (hyvä tieteellinen käytäntö jota noudatetaan,
%   tietosuoja, tieteellisen tutkimuksen rekisteriseloste)
% - kuvaa konkreetilla tasolla miten ja milloin aineisto kerätään, käsitellään,
%   talletetaan, arkistoidaan/hävitetään
% - Aikataulu! \chapter{Aineiston analyysi} 
% - analyysin kuvaus, millä menetelmällä analyysi tehdään

\chapter{Tulokset} 
\chapter{Johtopäätökset}
\printbibliography
\end{document}
